15.1. Торке, листе, ниске и петље
#################################

До сада смо бројачку петљу `for` користили само у комбинацији са
функцијом `range` чиме смо постизали да бројачка променљива узима
бројевне вредности из неког опсега. У овом поглављу ћемо се упознати и
са другим облицима коришћења петље `for` који ће нам омогућити да
анализирамо један по један елемент садржан у некој структури података.
      
Пролазак кроз торку/листу/ниску
-------------------------------

Петља ``for ... in ... :`` се може употребити и да се проће кроз све
елементе неке дате торке/листе/ниске. На пример, ако је ``l`` листа,
тада ``for i in l:`` проузрокује да променљива ``i`` узима редом
елементе листе ``l``, по један у сваком кораку. Илуструјмо то следећим
примером.

Оперативни системи
''''''''''''''''''

Дата је листа у којој се налази списак неколико оперативних
система. Исписаћемо све елементе ове листе (сваки у посебној линији).

.. activecode:: пролазак_кроз_листу_ос

   operativni_sistemi = ["windows", "linux", "android", "ios"]
   for sistem in operativni_sistemi:
       print(sistem)

Други начин је да употребимо бројачку променљиву и да елементима листе
приступамо на основу индекса. На тај начин уз сваки систем можемо
исписати и његов редни број. Бројачка променљива узима редом вредности
од 0, па све до броја који је за један мањи од дужине листе. Ако редни
бројеви иду од 1 па до дужине листе, редни број је у сваком кораку за
један већи од вредности бројачке променљиве.

.. activecode:: пролазак_кроз_листу_ос_1

   operativni_sistemi = ["windows", "linux", "android", "ios"]
   for i in range(len(???)):  # ispravi ovaj red
       print(i + 1, operativni_sistemi[0])  # ispravi ovaj red

Иако је некада неопходно употребити и овај приступ, јасно је да се у првој
варијанти добија јаснији и лепши текст програма.


Годишња доба
''''''''''''

.. questionnote::

   Годишња доба се понављају у круг: пролеће, лето, јесен, зима,
   пролеће, лето, јесен, зима, и тако даље. Напиши програм који
   исписује смену годишњих доба током пет година.

У овом задатку ћемо више пута пролазити кроз једну исту листу, па ћемо
употребити приступ на основу индекса. Ако су имена годишњих доба
написана у једној листи, тада је потребно исписивати редом елементе на
позицијама 0, 1, 2, 3, затим опет 0, 1, 2, 3 и тако даље.  Ако
направимо петљу у којој ће бројачка променљива узимати редом вредности
од 0 до 19 (то је 20 годишњих доба која се смењују током пет година),
тада се серија бројева 0, 1, 2, 3, 0, 1, 2, 3... може добити тако
што се узимају остаци при дељењу бројева од 0 до 19 бројем 4. Имајући ово
у виду, исправи наредни програм.
   
.. activecode:: годишња_доба

   godisnja_doba = ["пролеће", "лето", "јесен", "зима"]
   for i in range(5 * len(godisnja_doba)):
       print(godisnja_doba[i])   #  ispravi ovaj red
       

Пролазак кроз листу парова имена и презимена научника
'''''''''''''''''''''''''''''''''''''''''''''''''''''
      
У петљи можемо проћи и кроз све елементе листе парова.

.. questionnote::

   Ако је дата листа која садржи парове имена и презимена неколико
   научника, напиши програм који прави њихов списак, тј. исписује име и
   презиме сваког од научника у посебном реду.

Формирај прво списак неколико научника.

.. activecode:: списак_научника

   naucnici = [("Nils", "Bor"), ("Čarls", "Darvin"), ("Isak", "Njutn"), ("Marija", "Kiri")]


Један од начина да прођемо кроз листу парова је да се понашамо као да је у
питању било која друга листа и уведемо променљиву која ће имати
редом вредности једног по једног уређеног пара. Појединачним
елементима пара (имену и презимену), онда можемо да приступимо на
основу индекса у оквиру пара.
   
.. activecode:: списак_научника_1
   :include: списак_научника
   
   for naucnik in naucnici:   # ispravi ovaj red
       print(naucnik[0], naucnik[1])

Слично, можемо употребити и бројачку променљиву која ће пролазити кроз
индексе листе и затим сваком пару приступати на основу његовог индекса
у листи, а онда сваком елементу пара (имену и презимену) приступати на
основу његовог индекса у пару.
      
.. activecode:: списак_научника_3
   :include: списак_научника
		
   for i in range(len(naucnici)):
       naucnik = ???                     # ispravi ovaj red
       print(naucnik[0], naucnik[1])

Ипак, од свих, можда се најелегантније решење добија ако се употреби
могућност распакивања пара, тј. коришћења две променљиве које ће редом
узимати имена и презимена научника.
      
.. activecode:: списак_научника_2
   :include: списак_научника

   for (ime, prezime) in naucnici:
       print(ime, prezime)


Свако слово у посебном реду
'''''''''''''''''''''''''''

Већ сте видели да се у многим случајевима ниска може користити веома
слично као листа карактера. У том светлу, могуће је у петљи проћи кроз
све карактере ниске.
           
.. questionnote::

   Напиши програм који исписује слово по слово учитане речи, свако у
   посебном реду.

.. activecode:: пролаз_кроз_ниску
		
   niska = input("Unesi neki tekst: ")
   for karakter in niska:
       print(karakter)
		
Примена истог израчунавања на више података
-------------------------------------------

У неколико примера које смо срели до сада исто израчунавање
применили смо на више различитих података. Хајде да размотримо један пример тог
типа.

Последњи контролни
''''''''''''''''''
   
.. questionnote::

   Петар је током полугодишта радио четири контролна задатка и добијао је
   редом оцене 3, 5, 4, 2. Јуче је радио последњи контролни задатак и
   занима га која ће му бити закључна оцена ако добије 1, 2, 3, 4
   или 5. Напиши програм који то одређује.


.. activecode:: последњи_контролни_1

   ocene = [3, 5, 4, 2]
   zbir = sum(ocene)

   for poslednja_ocena in (1, 2, 3, 4, 5):
       zakljucna_ocena = round((zbir + poslednja_ocena) / 5)
       print("Ako dobije", poslednja_ocena,
             "biće mu zaključena ocena", zakljucna_ocena)
       
Пошто оцене које анализирамо чине опсег природних бројева, уместо
навођења вредности у торки, могли смо употребити и петљу облика ``for
poslednja_ocena in range(1, 6):``.

Учитавање и обрада листе
------------------------

У многим случајевима писање скриптова које ћемо сами користити је
задовољавајуће решење и навођење свих улазних вредности се може
урадити на почетку скрипта. Ипак, понекада желимо да испрограмирамо и
апликације које учитавају податке са улаза пре него што их обраде.
Када се подаци који се учитавају обрађују један по један (као што је
то био случај у претходним примерима), тада се учитавање може урадити
на почетку петље која врши обраду података и није неопходно користити
структуре података. Са друге стране, често желимо да пронађемо неку
заједничку статистику свих података (на пример, збир, просек, минимум
или максимум) и тада је згодно да све податке прво учитамо у листу да
бисмо онда обраду извршили коришћењем уграђених функција за рад са
листама. Ако података има баш много, ово може захтевати превише
меморије, па је обраду можда боље урадити ручном имплементацијом тих
алгоритама (што ћемо илустровати у наредном поглављу). Међутим, у
већини случајева је учитавање података у листу и након тога обрада те
листе сасвим задовољавајуће решење. Прикажимо неколико примера те
технике.

Просек учитаних оцена
'''''''''''''''''''''

.. questionnote::

   Напиши програм који учитава број оцена ученика, а затим и
   појединачне оцене (сваку у посебном реду) и на крају одређује и
   исписује просечну оцену тог ученика.

Елементе у листу можемо учитати тако што на почетку кренемо од празне
листе (листе ``[]``), а затим у петљи учитавамо један по један елемент
и додајемо га у листу методом ``append``.

.. activecode:: prosek_ucitanih_ocena

   broj_ocena = int(input("Unesi broj ocena:"))
   ocene = []
   for i in range(broj_ocena):
       ocena = int(input("Unesi ocenu:"))
       ocene.append(ocena)
   prosek = sum(ocene) / len(ocene)
   print("Prosek:", prosek)

Изврши корак по корак претходни програм и посматрај како се садржај
листе мења током учитавања њених елемената.

Трајање путовања
''''''''''''''''

.. questionnote::

   Трајање путовања зависи од брзине и растојања. Претпоставимо да у
   8.35 крећемо из Београда до Новог Сада и да треба да пређемо пут од
   93,38 km. Напиши скрипт који израчунава када ћеш стићи у Нови Сад
   ако се крећеш просечном брзином од a) 120 km/h, b) 110 km/h и c)
   100 km/h.


Најлошији приступ решавању проблема овог типа је то да се код који
врши израчунавање понови више пута у програму и да у том коду
варирају вредности улазних података.

.. activecode:: trajanje_putovanja_1

   s = 93.38
   polazak_min = (8*60 + 35)
   
   v = 120
   t_min = round((s / v) * 60)
   dolazak_min = polazak_min + t_min
   dolazak_sat = dolazak_min // 60
   dolazak_min = dolazak_min % 60
   print(dolazak_sat, ":", dolazak_min, sep="")

   v = 110
   t_min = round((s / v) * 60)
   dolazak_min = polazak_min + t_min
   dolazak_sat = dolazak_min // 60
   dolazak_min = dolazak_min % 60
   print(dolazak_sat, ":", dolazak_min, sep="")

   v = 100
   t_min = round((s / v) * 60)
   dolazak_min = polazak_min + t_min
   dolazak_sat = dolazak_min // 60
   dolazak_min = dolazak_min % 60
   print(dolazak_sat, ":", dolazak_min, sep="")

Ово решење је очигледно веома лоше јер се скоро идентичан програмски
код јавља на више места, што је компликовано било написати, а још теже
је одржавати (сваку измену је потребно поновити на три места). Један
од начина да се ово поправи је да се код организује у функције
које ће се онда позвати за различите вредности брзине.

.. activecode:: trajanje_putovanja_2

   def u_minute(sat, min):
       return sat*60 + min

   def od_minuta(min):
       return (min // 60, min % 60)

   def dolazak(polazak_sat, polazak_min, s, v):
       polazak_min = u_minute(polazak_sat, polazak_min)
       t_min = round((s / v) * 60)
       dolazak_min = polazak_min + t_min
       return od_minuta(dolazak_min)

   def ispisi_vreme_dolaska_bg_ns(v):
       s = 93.38
       (dolazak_sat, dolazak_min) = dolazak(8, 35, s, v)
       print(dolazak_sat, ":", dolazak_min, sep="")

   ispisi_vreme_dolaska_bg_ns(120)
   ispisi_vreme_dolaska_bg_ns(110)
   ispisi_vreme_dolaska_bg_ns(100)
                
Још један могући приступ решавању овог проблема заснива се на томе да
се израчунавање врши у петљи на почетку чијег тела се учитавају улазни
подаци. Проблем са овим приступом је то што корисник током рада
скрипта мора да унесе улазне податке (они више нису део скрипта).

.. activecode:: trajanje_putovanja_3

   s = 93.38
   polazak_min = (8*60 + 35)

   for i in range(3):
       v = int(input("Unesi brzinu:"))
       t_min = round((s / v) * 60)
       dolazak_min = polazak_min + t_min
       dolazak_sat = dolazak_min // 60
       dolazak_min = dolazak_min % 60
       print(dolazak_sat, ":", dolazak_min, sep="")

Проблеми овог типа се често решавају тако што се направи торка или
листа могућих вредности улазних података и петља која узима једну по
једну улазну вредност и за њу врши тражено израчунавање. На пример:

.. activecode:: trajanje_putovanja_4

   s = 93.38
   polazak_min = (8*60 + 35)
   brzine = (120, 110, 100)
   
   for v in brzine:
       t_min = round((s / v) * 60)
       dolazak_min = polazak_min + t_min
       dolazak_sat = dolazak_min // 60
       dolazak_min = dolazak_min % 60
       print(dolazak_sat, ":", dolazak_min, sep="")

Овај приступ не искључује дефинисање помоћних функција или процедура
(поготово ако се оне вишеструко могу употребити, тј. такве да се могу
користити и при решавању других задатака).

.. activecode:: trajanje_putovanja_5

   def u_minute(sat, min):
       return sat*60 + min

   def od_minuta(min):
       return (min // 60, min % 60)

   def dolazak(polazak_sat, polazak_min, s, v):
       polazak_min = u_minute(polazak_sat, polazak_min)
       t_min = round((s / v) * 60)
       dolazak_min = polazak_min + t_min
       return od_minuta(dolazak_min)

   s = 93.38
   brzine = (120, 110, 100)
   for v in brzine:
       (dolazak_sat, dolazak_min) = dolazak(8, 35, s, v)
       print(dolazak_sat, ":", dolazak_min, sep="")

.. infonote::

   Једна важна поука овог задатка је да разлика у брзини од целих 20 km/h 
   - што је разлика између опуштене вожње и јурцања по ауто-путу
   уз кршење прописа, а често може бити и разлика између живота и
   смрти - на овој релацији додаје свега 10
   минута. Дакле, опрезном вожњом се не губи много времена, али се много добија.
