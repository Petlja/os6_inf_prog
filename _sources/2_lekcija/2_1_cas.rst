2.1. Условне петље
################################

Понављање - условна петља `while`
---------------------------------

Погледај следећи пример у видеу. Лавиринт је зачаран, лоптица је увек на крају 
тунела, али се не зна његова тачна дужина. Сваки пут када вратиш робота на почетак, 
тунел у лавиринту је друге дужине. Робот и у таквом лавиринту треба увек да 
стигне до лоптице и узме је. Да ли овде помаже петља ``for``? Погледајмо видео!

.. ytpopup:: ItdBjmCgQFM
      :width: 735
      :height: 415
      :align: center

Поред наредби које робот може да извршава, а које смо користили у 
досадашњим програмима, робот Карел може да поставља следећа питања:

- ``moze_napred()`` - проверава да ли робот може да се помери напред (да
  ли испред њега постоји зид),
- ``ima_loptica_na_polju()`` - проверава да ли на пољу на ком се робот
  налази има лоптица,
- ``broj_loptica_na_polju()`` - враћа број лоптица на пољу на ком се
  робот налази,
- ``ima_loptica_kod_sebe()`` - проверава да ли робот тренутно има
  лоптица код себе.
- ``broj_loptica_kod_sebe()`` - враћа број лоптица које робот тренутно
  има код себе,

То ћемо искористити да бисмо Карела навели да реши неке мало компликованије задатке.

Хајде сада да уз помоћ новог алата, петље ``while``, решиш пример из видеа!

Иди напред док можеш
''''''''''''''''''''
   
.. questionnote::

   Наредни лавиринт је зачаран и не зна се колико тачно поља постоји између робота и лоптице. Напиши програм тако 
   да робот и у таквом лавиринту увек стиже до лоптице и узима је. Не заборави да помоћу ``mozeNapred()`` можеш проверити 
   да ли се робот може померити напред, тј. да ли се испред њега налази зид.

Петљу ``for`` најчешће користимо када знамо тачно колико пута желимо да се нешто понови. Међутим, постоји и други 
облик петље којим се обезбеђује да се наредбе понављају све док је неки услов испуњен. У овом програму желимо 
роботу да наредимо да иде напред *док* год је то могуће и након тога да покупи лоптицу. „Док“ се на енглеском 
језику каже *while*, па се и условна петља назива петља ``while``. Погледај како се она може употребити. Покрени 
наредни програм више пута и видећеш да исправно ради без обзира на то што се зачарани лавиринт променио.
   
.. karel:: Карел_иди_напред_док_можеш
   :blockly:

   {
      setup: function() {
           function random(n) {
              return Math.floor(n * Math.random());
	   }

	   var N = 3 + random(3);
	   var world = new World(N, 1);
           world.setRobotStartAvenue(1);
           world.setRobotStartStreet(1);
           world.setRobotStartDirection("E");
	   world.putBall(N, 1);
           var robot = new Robot();
	   var code = ["from karel import *",
                       "while mozeNapred():",
		       "    napred()",
		       "uzmi()"]
	   return {world: world, robot: robot, code: code};
      },

      isSuccess: function(robot, world) {
           var lastAvenue = world.getAvenues();
           return robot.getStreet() === 1 &&
           robot.getAvenue() === lastAvenue &&
	   world.getBalls(lastAvenue, 1) == 0;
      }
   }

Запамти, ``while`` значи док. У преходном програму смо, дакле, роботу
рекли следеће: "Док можеш да идеш напред, иди напред. Узми лоптицу."


Приметићете и да се након услова петље ``while`` пише двотачка, док се редови у којима се пишу наредбе које се 
понављају увлаче (веома слично као у случају петље ``for``). Сличне су и поруке о грешкама уколико се ово правило 
не испоштује.

И петљама ``while`` ћемо се детаљније бавити у поглављу `Понављање
<Ponavljanje.html>`_.

Купи лоптице док можеш
''''''''''''''''''''''
   
.. questionnote::

   Наредни лавиринт је зачаран и не зна се колико тачно има лоптица испред робота. Напиши програм којим робот 
   купи све те лоптице.

Један начин да се реши задатак је да се прво одреди колико је лоптица
на пољу на ком се робот налази, а затим да се употреби петља
``for``. Број лоптица на пољу се може одредити позивом
``broj_loptica_na_polju()``.

   
.. karel:: Карел_купи_лоптице_док_можеш
   :blockly:

   {
      setup: function() {
           function random(n) {
              return Math.floor(n * Math.random());
	   }

	   var world = new World(2, 1);
           world.setRobotStartAvenue(1);
           world.setRobotStartStreet(1);
           world.setRobotStartDirection("E");
	   var N = 5 + random(5);
	   world.putBalls(2, 1, N);
           var robot = new Robot();
	   var code = ["from karel import *",
	               "napred()",
		       "for i in range(broj_loptica_na_polju()):",
		       "    uzmi()"]
	   return {world: world, robot: robot, code: code};
      },

      isSuccess: function(robot, world) {
           return robot.getStreet() === 1 &&
           robot.getAvenue() === 2 &&
	   world.getBalls(2, 1) == 0;
      }
   }

Овим програмом се роботу каже следеће: „Онолико пута колико је на пољу лоптица, узми лоптицу.“

Други начин да се задатак реши је да се употреби петља ``while`` и да
се лоптице купе све док их има на пољу. Ту проверу робот може да
изврши коришћењем питања ``ima_loptica_na_polju()``.

Покушај да измениш претходни програм и задатак решиш на овај 
начин. Твој програм треба роботу да каже следеће: „Иди напред. Док има 
лоптица на пољу, узимај по лоптицу.“

.. reveal:: Карел_купи_лоптице_док_можеш_reveal
   :showtitle: Прикажи решење
   :hidetitle: Сакриј решење
   
   .. activecode:: Карел_купи_лоптице_док_можеш_решење
      :passivecode: true

      napred()
      while ima_loptica_na_polju():
          uzmi()




