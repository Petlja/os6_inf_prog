8.3. Ниске
##########

Приметили смо да смо приликом учитавања (наредбе ``input``) или исписа
(наредбе ``print``) текст који се дословно приказује кориснику
наводили између наводника. Такав текст назива се **ниска** или
**стринг** (од енглеске речи string која значи ниска). На пример,
ниске су ``"Zdravo"`` или ``"Programski jezik Python."``.  Уместо
двоструких равноправно се могу користити и једноструки наводници (на
пример, ``'Zdravo'``), међутим, да бисмо вас мање збуњивали, ми ћемо
увек користити двоструке наводнике.

Текст (па и ниске) се састоји од слова (малих и великих), цифара,
размака, интерпункцијских знакова (на пример тачака, зареза, упитника,
узвичника) и слично. Све те знакове једним именом називамо
**карактери**. Неки програмски језици подржавају само веома узак скуп
карактера (од слова је могуће користити само слова енглеске абецеде),
међутим, програмски језик Python3 користи широк скуп карактера који
обухвата и све карактере потребне за писање на већини језика света,
укључујући и слова ћириличног и латиничног писма која се користе у
српском језику.

.. infonote::

   Поменути основни скуп карактера довољан само за запис текста на
   енглеском језику назива се ASCII, док се овај шири скуп карактера
   назива Unicode.

.. infonote::

   У језику Python 3 могуће је и имена променљивих написати ћирилицом,
   међутим, то некада може довести до проблема (ако се, на пример,
   едитор текста који се користи да се програм откуца не подеси
   адекватно), тако да ћемо за сваки случај имена променљивих увек
   писати латиницом, без коришћења српских слова (š, ž, č, ...).
      

.. level:: 2
   :container:
      
   .. infonote::

     Ако текст садржи знаке наводника или неке друге специјалне
     карактере потребно је те карактере обележити косим цртама. На
     пример, ``"Rekao je: \"Zdravo, svima\".`` Ове косе црте се не
     исписују приликом извршавања програма и штампања ниски.

     .. activecode:: escape_sequence
		   
         print("Rekao je: \"Zdravo, svima\".")   
         
Текст може бити сачуван и у променљивама. На пример,

.. activecode:: поздрави_перу

   ime = "Pera Perić"
   print("Zdravo, ti se zoveš", ime)
   
Текст можемо учитати и од корисника, након покретања програма. За то
можемо употребити функцију ``input``. На пример, наредни програм пита
корисника како се зове, а онда га поздрави.

.. activecode:: поздрави_корисника

   ime = input("Unesi svoje ime: ")
   print("Zdravo, ti se zoveš", ime)

Приметимо да се приликом учитавања бројева заправо учитава текст
(помоћу ``input``), а онда се из учитаног текста одређују бројеви који
су тим текстом представљени. Таква претварања (конверзије) текста у
број врше се помоћу ``int`` и ``float``.

Радом са текстом и нискама ћемо се много детаљније бавити током наредних
часова.
         
Аутоматско тестирање програма
-----------------------------

У програмирању је веома битно да програми које напишеш увек дају тачне
резултате. Најчешћи начин да се провери коректност програма је да се
он покрене на већем броју унапред припремљених тест-примера (у којима
су дате различите вредности улазних параметара) и да се провери да ли
на њима даје очекиване резултате. Ако програм на њима исправно ради,
веома вероватно је да ће исправно радити и на свим другим
примерима. Трудили смо се да у наставку омогућимо аутоматско тестирање
на што већем броју задатака. Један такав је и наредни.


.. questionnote::

   Марко је прочитао књигу за три дана. Првог дана је прочитао 100
   страна. Другог дана је прочитао 17 страна више него првог, а трећег
   два пута више него другог. Колико та књига има страна? Напиши
   програм који то одређује, а ради исправно и када је број страна
   прочитаних првог дана другачији од 100.

Програм је у тренутном облику неисправан (увек исписује
нулу). Притисни дугме **Тестирај програм** и видећеш да резултати који
се добију нису једнаки оним очекиваним и приказаће ти се поља црвене
боје, што указује на грешке.

.. activecode:: читање
   :runortest: prvi_dan, ukupno
   :enablecopy:

   # -*- acsection: general-init -*-
   # -*- acsection: var-init -*-
   prvi_dan  = 100
   # -*- acsection: main -*-
   drugi_dan = 0      # popravi ovaj red
   treci_dan = 0      # popravi ovaj red
   ukupno = 0         # popravi ovaj red
   # -*- acsection: after-main -*-
   print(ukupno)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
          for prvi_dan, ukupno in [(84, 387), (122, 539), (153, 663)]:
             self.assertEqual(acMainSection(prvi_dan = prvi_dan)["ukupno"],ukupno,"Ако је први дан прочитао %s стране, број страна књиге је %s." % (prvi_dan, ukupno))
   myTests().main()

Поправи претходни програм тако што ћеш изменити само оне редове који
су обележени - друге редове не дирај. Када завршиш поново притисни
дугме **Тестирај програм**. Ако је све како треба, приказаће ти се три
поља зелене боје. Наиме, када притиснеш то дугме програм се тестира на
основу неколико унапред припремљених тестова. Програм се неколико пута
пушта из почетка (за сваки тест по једном), али тако да се уместо
вредности ``100`` променљивој ``prvi_dan`` додељују неке друге
вредности (у овом конкретном примеру покушава се са вредностима
``84``, ``122`` и ``153``). Након тога програм који си
написао/написала израчунава укупан број страна и резултат који је твој
програм израчунао се пореди са стварним бројем страна књиге за тај
тест (за улаз ``84`` стварни број страна је ``387``, за улаз ``122``
стварни број страна је ``539``, а за улаз ``153`` стварни број страна
је ``663``). Ако се та два броја поклапају, на том случају за ту почетну
вредност се приказује зелена боја, а ако не, приказује се црвена боја.
   
Извршавање корак по корак
-------------------------

Једна корисна техника која помаже да се боље разуме начин рада неког
програма, али и да се уоче и исправе евентуалне грешке у програму је
то да се програм извршава корак по корак, тј. да се извршава једна по
једна његова наредба, при чему се након сваке извршене наредбе прати
вредност променљивих у програму.

.. infonote::

   Извршавање програма корак по корак уз праћење вредности свих
   међурезултата назива се **дебаговање** (требљење од бубица) и јако
   је важна техника за откривање грешака у програмима. У старим
   рачунарима који су били велики као читава соба, дешавало се да
   мољци и сличне бубе уђу у рачунар и проузрокују неки квар. Од тада
   се све грешке у програмима називају **багови** тј. **бубице**.
   
Илуструјмо ову могућност на сајту Петље кроз наредни, једноставни,
пример.

Воћњак са јабукама
''''''''''''''''''

.. level:: 1

.. questionnote::
   
   Пера је засадио 380 стабала јабуке. Ђура је засадио 142 стабла јабука
   више од Пере, а Мика је засадио два пута више од Пере. Колико су
   стабала засадили заједно?


.. activecode:: јабуке
   :runortest: pera, zajedno
   :enablecopy:
   
   Исправи следећи програм тако да исправно израчунава колико су
   стабала засадили заједно (програм треба исправно да ради и ако се
   број стабала које је засадио Пера промени).
   
   ~~~~
   # -*- acsection: general-init -*-
   # -*- acsection: var-init -*-
   pera = 380
   # -*- acsection: main -*-
   djura = ???
   mika = ???
   zajedno = pera + djura + mika
   # -*- acsection: after-main -*-
   print(zajedno)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
          for pera, zajedno in [(100, 542), (200, 942)]:
             self.assertEqual(acMainSection(pera = pera)["zajedno"],zajedno,"Ако је Пера засадио %s стабала, заједно су засадили %s стабала." % (pera, zajedno))
   myTests().main()
   
Притисни сада дугме **Корак по корак**. Оно ти пружа могућност да
програм извршаваш корак по корак. Дугметом *Forward* извршаваш
наредну наредбу (ону обележену црвеном стрелицом). Наредба која је
претходно извршена обележена је светло-плавом стрелицом. У делу
*Frames* можеш видети вредности свих до сада израчунатих резултата,
док у прозору тога можеш видети излаз програма (резултате одштампане
наредбом ``print``).

И у овом задатку је омогућено аутоматско тестирање, па дугметом
**Тестирај програм** провери да ли је твоје решење тачно.




