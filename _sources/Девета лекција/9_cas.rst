Час 9 - Коришћење и дефинисање функција
#######################################

Уграђене функције
=================

Појам функције
--------------
	   
**Функције** су један од основних појмова математике и
програмирања. Оне представљају пресликавања одређених улазних
вредности (каже се параметара, аргумената) у једну или више излазних
вредности тј. резултата. На пример, функција може да као улазни
параметар добије дужину странице једнакостраничног троугла :math:`а` и
да као резултат врати дужину обима тог троугла :math:`3\cdot a`. Таква
зависност би се у математици описала као :math:`f(a) = 3\cdot a` што
значи да функција коју смо назвали `f` (што је најчешће име за
функцију) на основу датог параметра :math:`а` одређује вредност
:math:`3\cdot a`. Слично, функција која израчунава обим правоугаоника
на основу дужине његових страница би се у математици описала као
:math:`g(a, b) = 2\cdot a + 2 \cdot b`. У овом случају је функцији дат
назив :math:`g`, она има два улазна параметра (:math:`a` и :math:`b`)
и враћа резултат који је одређен формулом :math:`2\cdot a + 2 \cdot
b`.

Касније ћемо видети како можемо дефинисати функције у језику Python, а
за почетак ћемо се само позабавити коришћењем неких основних уграђених
функција (оне су већ дефинисане језиком и можемо их слободно користити
тј. позивати у нашим програмима). У наставку ћемо детаљније описати
следеће функције:

- ``min``, ``max`` - минимум и максимум
- ``abs`` - апсолутна вредност
- ``math.pow``, ``math.sqrt`` -  степен, квадратни корен
- ``round``, ``math.floor``, ``math.ceil`` - заокругљивање реалних
  бројева
  
Минимум и максимум
------------------

У многим задацима потребно је одредити мањи или већи од два дата
броја. Пошто је тај задатак веома чест, програмски језик Python нуди
решење у виду функција ``min`` и ``max``. На пример, вредност израза
``min(2, 5)`` је мањи од бројева 2 и 5 тј. број 2 (тај израз
представља позив функције ``min`` са аргументима ``2`` и ``5``), док
је вредност израза ``max(2, 5)`` већи од бројева 2 и 5 тј. број 5 (тај
израз представља позив функције ``max`` са аргументима ``2`` и ``5``).

.. fillintheblank:: fill_минимум
		    
      Вредност израза ``min(24, 17)`` је |blank|

      -     :17: Тачно!
            :x: Нетачно. min означава мањи број

.. mchoice:: mchoice_минимум
   :answer_a: 2
   :answer_b: 3
   :answer_c: 5
   :correct: a
   :feedback_a: Тачно!
   :feedback_b: min означава мањи од два броја.
   :feedback_c: min означава мањи од два броја. 
		
   Која је вредност израза ``min(min(5, 2), 3)``?

Минимум и максимум неколико бројева могуће је израчунати тако што се
сви наведу као параметри функција `min` тј. `max`. На пример, вредност
израза ``max(3, 2, 5, 4)`` је ``5``.

Покажимо сада неколико задатака у чијем нам решењу ове функције могу
помоћи.

Већа оцена
''''''''''
.. level:: 1
  
.. questionnote::

   Љубица је једног дана добила оцену из биологије и географије. Која
   је већа оцена коју је Љубица добила тог дана?

.. activecode:: већа_оцена

   biologija  = int(input("biologija: "))
   geografija = int(input("geografija: "))
   print("veća ocena: ", 0)  # ispravi ovu liniju

Највећи број поена у игрици
'''''''''''''''''''''''''''
.. level:: 1
   
.. questionnote::

   Асмир, Снежа и Мица су играли игрицу на рачунару. Колики је највећи
   број поена (high-score) који је освоји неко од њих.

.. activecode:: највећи_број_поена
   :runortest: asmir, sneza, mica, najveci
   :enablecopy:
      
   # -*- acsection: general-init -*-
   # -*- acsection: var-init -*-
   asmir = int(input("Koliko je poena osvojio Asmir: "))
   sneza = int(input("Koliko je poena osvojila Sneža: "))
   mica  = int(input("Koliko je poena osvojila Mica: "))
   # -*- acsection: main -*-
   najveci = 0 # ispravi ovu liniju
   # -*- acsection: after-main -*-
   print("Највећи број поена је: ", najveci)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
          for asmir, sneza, mica in [(3542, 2388, 4123), (3562, 4221, 1002), (7428, 2842, 9413)]:
             self.assertEqual(acMainSection(asmir = asmir, sneza = sneza, mica = mica)["najveci"],max(asmir, sneza, mica),"Ако су редом освајали %s, %s и %s поена, тада је највећи број поена %s." % (asmir, sneza, mica, max(asmir, sneza, mica)))
   myTests().main()
   



   
Апсолутна вредност
------------------

Још једна веома корисна функција коју си упознао/упознала у математици
је апсолутна вредност. Апсолутном вредношћу се одређује одступање
броја од нуле.  На пример, број 4 одступа од нуле за 4, док број -5
одступа од нуле за 5 јединица. Дакле апсолутна вредност броја
:math:`x`, која се, подсетимо се, обележава са :math:`|x|`, једнака је
самом броју :math:`x` ако је :math:`x \geq 0` тј.  броју :math:`-x`,
ако је :math:`x < 0`.

У језику Python апсолутну вредност можемо израчунати помоћу функције
``abs``. Тако је вредност израза ``abs(5)`` једнака ``5``, док је
вредност израза ``abs(-3)`` једнака 3.

.. fillintheblank:: fill_апсолутна_вредност
		    
      Вредност израза ``abs(-11.2)`` је |blank|

      -     :11.2: Тачно!
            :x: abs означава апсолутну вредност броја и она не може бити негативна


Једна од најзначајнијих примена апсолутне вредности је да се израчуна
удаљеност бројева, без обзира на њихов међусобни однос. Наиме,
растојање између бројева :math:`x_1` и :math:`x_2` је једнако
апсолутној вредности њихове разлике тј. вредности :math:`|x_1 - x_2|`,
без обзира да ли је :math:`x_1 \geq x_2` или је :math:`x_1 <
x_2`. Размотримо наредни задатак.

Удаљеност спратова
''''''''''''''''''
.. level:: 1

.. questionnote::

   Cпратови у једној згради су обележени бројевима од -2 до 10
   (бројеви -2 и -1 означавају два нивоа испод земље, 0 означава
   приземље, док остали бројеви означавају спратове изнад земље). Ако
   се знају спратови на којима се налазе два другара, израчунај колико
   су спратова удаљени.

Пошто не знамо да ли лифт иде на горе или на доле тј. да ли је полазни
спрат мањи или већи од долазног, растојање између спратова можемо
израчунати тако што израчунамо апсолутну вредност разлике између тих
спратова. На пример, ако би први другар био на трећем спрату, а други
у првом подруму, исправи програм који рачуна то растојање.
   
.. activecode:: лифт_апсолутна_вредност
		
   sprat1 = 3
   sprat2 = -1
   rastojanje = abs(sprat1 - sprat2)
   print(rastojanje)

Наравно, уместо бројева 3 и -1 могуће је стављати и друге, а могуће је
ове бројеве учитати приликом покретања програма. Пробај са неколико
својих тест-примера, а пробај и са тест-примерима које смо ти ми
припремили.

.. activecode:: лифт_апсолутна_вредност_input
   :runortest: sprat1, sprat2, rastojanje
		
   # -*- acsection: general-init -*-
   # -*- acsection: var-init -*-
   sprat1 = int(input("На ком се спрату налази први другар?"))
   sprat2 = int(input("На ком се спрату налази други другар?"))
   # -*- acsection: main -*-
   rastojanje = 0 # ispravi svoj red
   # -*- acsection: after-main -*-
   print(rastojanje)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):
       def testOne(self):
          for sprat1, sprat2 in [(8, 4), (3, 6), (-1, 8), (4, -2)]:
             self.assertEqual(acMainSection(sprat1 = sprat1, sprat2 = sprat2)["rastojanje"],abs(sprat1-sprat2),"Растојање између спратова %s и %s је %s." % (sprat1, sprat2, abs(sprat1-sprat2)))
   myTests().main()
   

Менхетн растојање
'''''''''''''''''
.. level:: 1
      
.. questionnote::

   Менхетн, део града Њујорка је организован у авеније у правцу
   север-југ и улице у правцу isток-запад. Размак између две улице је
   80m, а између две авеније је 275m. Ако се Том налази на углу улице
   :math:`u_1` и авеније :math:`a_1` и жели да стигне на угао улице
   :math:`u_2` и авеније :math:`a_2`, колико ће метара морати да
   пређе.

.. image:: ../../_images/manhattan_distance.png
   :width: 500px   
   :align: center

Том има више начина да стигне са једног на друго место (може да иде
цик-цак, на разне начине), међутим, пређено растојање је исто као када
би прво ишао улицом :math:`u_1` све док не дође до угла са авенијом
:math:`a_2`, а затим да се креће авенијом :math:`а_2` све док не дође
до угла са улицом :math:`u_2`. Дакле, потребно је израчунати растојање
између авенија :math:`a_1` и :math:`a_2` (да би се оно добило у
метрима потребно је помножити апсолутну разлику између њихових редних
бројева размаком између суседних авенија) и на то додати растојање
између улица :math:`u_1` и :math:`u_2` (да би се оно добило у метрима
потребно је помножити апсолутну разлику између њихових редних бројева
размаком између суседних улица).
	   
Исправи наредни код тако да коректно израчуна пређени пут (наравно, програм
треба да ради и када се улазни подаци промене или учитају са улаза).
	   
.. activecode:: менхетн
   :runortest: ulica1, avenija1, ulica2, avenija2, rastojanje, razmak_ulica, razmak_avenija

   # -*- acsection: general-init -*-
   # -*- acsection: var-init -*-
   razmak_ulica = 80	
   razmak_avenija = 275
   ulica1 = 51
   avenija1 = 6
   ulica2 = 58
   avenija2 = 3
   # -*- acsection: main -*-
   rastojanje = abs(avenija1 - avenija2) * 0 + \
                0 * razmak_ulica
   # -*- acsection: after-main -*-
   print(rastojanje)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):

       def testOne(self):
          for (ulica1, avenija1, ulica2, avenija2, razmak_ulica, razmak_avenija, rastojanje) in [(3, 5, 8, 4, 80, 275, 675), (1, 7, 2, 4, 80, 275, 905), (9, 4, 11, 2, 80, 275, 710), (4, 8, 1, 5, 80, 275, 1065)]:
             self.assertEqual((acMainSection(ulica1 = ulica1, avenija1 = avenija1, ulica2 = ulica2, avenija2 = avenija2, razmak_ulica = razmak_ulica, razmak_avenija = razmak_avenija)["rastojanje"]),  rastojanje , "Растојање између тачака (%s, %s) и (%s, %s) је %s." % (ulica1, avenija1, ulica2, avenija2, rastojanje))
   myTests().main()
   

Приметимо да је формула у претходном примеру била веома дугачка и
проценили смо да је прегледније да је одштампамо кроз више редова. Да
бисмо нагласили да се нека наредба наставља и у следећој линији на
крај линије стављамо симбол ``\``.

.. reveal:: менхетн_решење1
   :showtitle: Прикажи решење
   :hidetitle: Сакриј решење

   .. activecode:: менхетн_решење2

      ulica1 = 51
      avenija1 = 6
      ulica2 = 58
      avenija2 = 3
      razmak_ulica = 80		
      razmak_avenija = 275
      rastojanje = abs(avenija1 - avenija2) * razmak_avenija + \
                   abs(ulica1 - ulica2) * razmak_ulica
      print(rastojanje)

Краљево растојање на шаховској табли
''''''''''''''''''''''''''''''''''''
.. level:: 3

.. questionnote::

   Краљ се на шаховској табли налази на пољу обележеном координатама
   :math:`(x_1, y_1)`. Ако се зна да се у сваком потезу краљ може
   кретати по једно поље у било ком од осам смерова, израчунај колики
   је најмањи број потеза потребних да краљ стигне на поље означено
   координатама :math:`(x_2, y_2)`.


Овај задатак је донекле сличан претходном. Поново је потребно да
израчунамо хоризонтално и вертикално растојање између полазне и
долазне тачке. Размисли како се број потеза може израчунати на основу
та два растојања (у првих неколико потеза краљ може да се креће
дијагонално, а после тога, ако је потребно, наставиће да се креће
хоризонтално тј. вертикално). Допуни дефиницију функције која
израчунава број потеза краља између поља ``(x1, y1)`` и ``(x2, y2)``.
   
.. activecode:: краљ_на_шаховској_табли
   :nocodelens:
      
   def kralj(x1, y1, x2, y2):
       broj_poteza = 0      # na ovom mestu izracunaj broj poteza
       return broj_poteza
   ====
   from unittest.gui import TestCaseGui

   class myTests(TestCaseGui):
       def testOne(self):
          self.assertEqual(kralj(3, 8, 5, 2), 6, "Ако краљ треба да стигне са поља (3, 8) на поље (5, 2) потребно му је 6 потеза.")
          self.assertEqual(kralj(7, 4, 3, 7), 4, "Ако краљ треба да стигне са поља (7, 4) на поље (3, 7) потребно му је 4 потеза.")
          self.assertEqual(kralj(1, 8, 8, 1), 7, "Ако краљ треба да стигне са поља (1, 8) на поље (8, 1) потребно му је 7 потеза.")
          self.assertEqual(kralj(5, 5, 2, 2), 3, "Ако краљ треба да стигне са поља (5, 5) на поље (2, 2) потребно му је 3 потеза.")

   myTests().main()


.. reveal:: краљево_растојање_решење1
   :showtitle: Прикажи решење
   :hidetitle: Сакриј решење

   Хоризонтално и вертикално растојање израчунавамо као апсолутну
   вредност разлике одговарајућих координата. Број дијагоналних потеза
   једнак је мањем од два растојања, док је број хоризонталних
   тј. вертикалних потеза након тога једнак разлици између већег и
   мањег растојања. Дакле, укупан број потеза је једнак већем од два
   растојања. Заиста, у почетним потезима се оба растојања умањују за
   по један, све док мање растојање не достигне нулу, након чега дуже
   растојање наставља да се умањује за један и укупан број потеза да
   оно достигне нулу једнак је његовој полазној вредности.
	       
   .. activecode:: краљ_на_шаховској_табли_решење2
		
      x1 = 3
      y1 = 8
      x2 = 5
      y2 = 2
      broj_poteza = max(abs(x1 - x2), abs(y1 - y2))
      print(broj_poteza)

Остале математичке функције
---------------------------
.. level:: 3

Поред ових које смо видели, језик Python 3 нуди многе друге корисне
функције за рад са бројевима. На пример, функција ``round`` заокружује
дати реални број на најближи цео број.

.. dragndrop:: round
    :feedback: Покушај поново
    :match_1: round(2.1)|||2
    :match_2: round(2.9)|||3
    :match_3: round(4.5)|||5

    Превлачењем упари изразе са њиховим вредностима.

Слично, функција ``math.ceil`` заокружује дати реалан број навише
тј. на најмањи цео број већи или једнак њему, док ``math.floor``
заокружује дати реалан број наниже тј. на највећи цео број мањи или
једнак њему. На пример, ``math.ceil(2.1)`` је ``3``, исто као и
``math.ceil(2.9)``, док је ``math.floor(2.1)`` једнако ``2``, исто као
и ``math.floor(2.9)``. Приметимо да имена ових функција почињу са
``math``. Оне су део такозване математичке библиотеке и да би се могле
користити у програму на његовом почетку мора бити написано ``import
math``.

.. fillintheblank:: fill14121
		
      Вредност ``math.ceil(7.25)`` је |blank|  
      Вредност ``math.floor(7.25)`` је |blank|  

      -     :8: Taчно!
            :x: размисли који је најмањи цео број који је већи или једнак 7,25
      -     :7: Taчно!
            :x: Размисли који је највећи цео број који је мањи или једнак 7,25


Функција ``math.sqrt`` израчунава квадратни корен тј. онај ненегативан
број који када се помножи сам са собом (када се квадрира) даје полазни
број. На пример, важи да је :math:`2 \cdot 2 = 4`, тако да је
квадратни корен броја :math:`4` број :math:`2` (то се у математици
записује као :math:`\sqrt{4} = 2`.

.. questionnote::

   Напиши програм који за дату површину квадрата израчунава дужину његове
   странице.

Пошто важи да је :math:`P = a\cdot a`, важи да је :math:`a = \sqrt{P}`.
   
.. activecode:: страница_квадрата

     import math
     P = float(input("Unesi površinu kvadrata:"))
     a = 0.0    # ispravi ovaj red
     print("Dužina stranice je: ", a)

Функција ``math.pow`` врши степеновање. На пример, :math:`2^{8} = 256`
се може израчунати помоћу ``math.pow(2, 8)``. Као што множење означава
узастопно сабирање, тако степеновање означава узастопно множење. Други
степен броја :math:`2` je :math:`2^2 = 2 \cdot 2 = 4`, трећи степен
броја :math:`2` је :math:`2^3 = 2 \cdot 2 \cdot 2 = 8` и тако даље.
Поменимо и да је степен дефинисан и када аргументи нису цели бројеви,
али се тиме нећемо бавити. Степеновање се може израчунати и оператором
``**``. Тако се уместо ``math.pow(2, 8)`` може употребити израз ``2 **
8`` чија је вредност такође ``256``.

Осим функција, у библиотеци ``math`` дефинисане су и разне корисне
константе. На пример, број :math:`\pi` који представља однос пречника
и обима круга доступан је помоћу ``math.PI`` (вредност тог броја је
око :math:`3,141592`).

Дефинисање функција
===================

Видели смо колико је корисно када на располагању имамо дате функције
попут ``min``, ``max`` или ``abs``. Сви програмски језици, па и Python
допуштају корисницима да дефинишу своје функције.

У програмима са корњача-графиком смо се срели са дефинисањем
**процедура**, што нам је омогућило да проширимо језик који корњача
разуме и да лакше пишемо програме. Једном када се дефинише процедура,
практично нема разлике између њеног коришћења и коришћења неке од
уграђених наредби, тако да су нам процедуре заправо дале начин да
дефинишемо нове, сложеније наредбе корњачи. **Функције** су веома
сличне процедурама, са главном разликом да функције служе да на основу
улазних вредности израчунају неки резултат и врате га, док процедуре
служе да промене стање програма и обично не враћају никакав резултат.
На пример, `abs` је функција која на основу дате вредности броја
одређује његову апсолутну вредност, док је `kvadrat(a)` процедура која
не враћа никакву вредност већ наређује корњачи да нацрта квадрат на
екрану. `input`, коју смо користили за учитавање са тастатуре је
функција (јер враћа унету вредност), док је `print` процедура (јер не
враћа никакву вредност, већ мења стање програма тј. оно што је
исписано на екрану).

.. infonote::

   Јасна подела на процедуре и функције уведена је у програмском
   језику Pascal. У Python-у се за обе врсте потпрограма користи иста
   кључна реч ``def``, па се стога често не прави разлика између ова
   два облика потпрограма, већ се говори о функцијама које враћају и
   функцију које не враћају вредности.


Примери дефинисања функција
---------------------------

На пример, функција која израчунава обим правоугаоника се може
дефинисати и онда употребити на следећи начин.

.. activecode:: функција_површине_правоугаоника

   def obim_pravougaonika(a, b):
       return 2 * a + 2 * b

   print(obim_pravougaonika(3, 5))
   print(obim_pravougaonika(4.2, 5.7))
   
Дефиниција функције почиње речју ``def`` након тога се наводи назив
функције, затим у заградама наведени улазни параметри функције и
симбол двотачка (``:``).  Након те прве линије наводи се тело
функције, које мора бити мало увучено.  Код најједноставнијих функција
(као што су ове две наведене у примерима) тело функције представља
само наредба ``return`` након које се налази израз који представља
везу између улазних параметара и резултата функције. Код
компликованијих функција у телу се налазе дужа израчунавања, али се и
даље у телу функције (најчешћње на самом крају) налази наредба
``return`` иза које се наводи вредност функције (то може бити и име
променљиве у којој је израчуната резултујућа вредност). Функције се
позивају тако што се наведе њихов назив и у загради вредности
аргумената.

Обим квадрата
'''''''''''''
.. level:: 1

.. questionnote::

   Дефиниши функцију која на основу дужине странице израчунава
   површину квадрата.

   
.. activecode:: површина квадрата

   def povrsina_kvadrata    # dopuni ovaj i naredni red
       return 

   a = int(input("Unesi dužinu stranice kvadrata: "))
   print(povrsina_kvadrata(a))

Површина сложених облика
''''''''''''''''''''''''
.. level:: 2

Размотримо проблем израчунавања површине наредних сложених облика.

.. image:: ../../_images/slozeni_oblik.png
   :width: 300px   
   :align: center

.. image:: ../../_images/slozeni_oblik_polukrugovi.png
   :width: 300px   
   :align: center

Први облик се може разложити на два правоугаоника, један правоугли
троугао и један полукруг, док се површина другог облика може добити
тако што се од површине највећег полукруга одузме површина најмањег, а
дода површина средњег полукруга и површина правоуглог троугла.

Ако једном дефинишемо функције за израчунавање површине сваког од тих
елементарних облика, веома једноставно у главном програму можемо
израчунавати површине разних сложених облика, не размишљајући више о
формулама потребним за израчучнавање површине појединачних облика
(површина правоугаоника страница :math:`a` и :math:`b` израчунава се
по формули :math:`P=a\cdot b`, површина правоуглог троугла чије су
странице које образују прав угао :math:`a` и :math:`b` једнака је
:math:`\frac{a\cdot b}{2}`, јер је тај троугао половина одговарајућег
правоугаоника, а површина круга полупречника :math:`r` може се
израчунати по формули :math:`P = r^2\pi`, где је :math:`pi =
3,1415926...`, а у језику Python се може добити помоћу `math.pi`).

.. activecode:: сложени_облици

   # površina pravougaonika datih stranica
   def P_pravougaonika(a, b):
       return a * b

   # površina pravouglog trougla datih kateta
   def P_pravouglog_trougla(a, b):
       return a * b / 2

   # površina kruga datog poluprečnika
   def P_kruga(r):
       return r * r * math.pi

   # površina polukruga datog prečnika
   def P_polukruga(R):
       return P_kruga(R / 2) / 2

   P1 = (P_pravougaonika(2, 3) + ??? + 
         P_pravouglog_trougla(2, 1) + P_polukruga(3))
   P2 = (P_polukruga(7) - P_polukruga(2) + ??? + 
         P_pravouglog_trougla(???, ???))

   print(P1, P2)
   

Функције са више резултата
--------------------------
У неким ситуацијама функција треба да врати више вредности. На пример,
желимо да претварање центиметара у метре и центиметре опишемо у облику
посебне функције. Резултат тада можемо вратити у облику пара или торке
елемената (више речи о паровима и торкама је дато у поглављу о
представљају података у програмима).

.. activecode:: функција_конверзије_дужине

   def cm_u_mcm(cm):
       return (cm // 100, cm % 100)

   (m, cm) = cm_u_mcm(178)
   print(178, "cm", "=", m, "m", "i", cm, "cm")
   (m, cm) = cm_u_mcm(161)
   print(161, "cm", "=", m, "m", "i", cm, "cm")

Секунде у сате, минуте и секунде
''''''''''''''''''''''''''''''''
.. level:: 2

.. questionnote::

   Напиши функцију која на основу броја секунди протеклих од претходне
   поноћи израчуна тренутно време у сатима, минутима и секундама,
   водећи рачуна да број сати буде између 0 и 23.

У наредној дефиницији функције направљено је неколико грешака. Исправи
је тако да наредни програм да исправне резултате.
   
.. activecode:: функција_конверзије_времена
		
  def sek_u_satminsek(s):
      sek = (s // (60*60)) % 24
      min = (s // 1) % 60
      sat = (s // 60) % 60
      return                  # dopuni ovaj red

  (sat, min, sek) = sek_u_satminsek(1000)
  print(sat, ":", min, ":", sek)
  () = sek_u_satminsek(7200)      # dopuni ovaj red
  print(sat, ":", min, ":", sek)

Када програм покренеш треба да испише ``0 : 16 : 40`` и ``2 : 0 : 0``.

Сврха дефинисања функција
-------------------------

Резимирајмо на крају неколико основних разлога за дефинисање функција.

- Увођењем функција добијају се разумљивији програми (ономе ко чита
  главни програм много је јасније да се у неком делу израчунава обим
  правоугаоника ако у програму види израз ``obim_pravougaonika(2, 5)``
  него ако види израз ``2 * 2 + 2 * 5)``). Када дефинишемо погодне
  функције, главни програм је било много лакше написати.

- Функције помажу да се програм скрати тако што се избегава понављање
  истог програмског кода (ако је тај програмски код дугачак и
  компликован, издвајање у функцију може значајно поједноставити и
  скратити програм). Ако се покаже да је тај део кода често потребно
  мењати (што је често случај у програмирању) то што се код јавља само
  једном (у склопу тела функције) чини одржавање много једноставнијим
  (не морамо измене да правимо на пуно места, већ само на једном).

- Функције помажу и да се неки проблеми реше, тако што омогућавају
  разлагање комплексних проблема на једноставније потпроблеме.


Домаћи задатак
--------------

Уради за домаћи неколико наредних задатака.

Време чекања на станици
'''''''''''''''''''''''
.. level:: 2

.. questionnote::

   Јелена је дошла аутобусом на станицу у s1 сати и m1 минута, док је
   Иванин аутобус стигао у s2 сати и m2 минута. Колико је сати и
   минута она која је прва стигла чекала ону која је друга стигла?

И у овом задатку се тражи да се израчуна растојање између два
временска тренутка за које се не зна који је први, а који други. Као
што смо приказали раније, рачунање растојања се своди на рачунање
апсолутне вредности разлике, а рад са сатима и минутима лакше обављамо
ако прво претворимо све у минуте, затим израчунамо број минута колико
су се чекале и након тога то претворимо у сате и минуте.
   
.. activecode:: чекање_на_станици
   :runortest: s1, m1, s2, m2, s, m
      
   # -*- acsection: general-init -*-
   # -*- acsection: var-init -*-
   s1 = int(input())
   m1 = int(input())
   s2 = int(input())
   m2 = int(input())
   # -*- acsection: main -*-
   vreme1 = 0  # pretvori u ovom redu s1 sati i m1 minuta u minute
   vreme2 = 0  # pretvori u ovom redu s2 sati i m2 minuta u minute
   vreme = 0   # izracunaj u ovom redu duzinu cekanja u minutima
   s = 0       # u ovom redu izracunaj broj sati cekanja
   m = 0       # u ovom redu broj minuta cekanja
   # -*- acsection: after-main -*-
   print(s, m)
   ====
   from unittest.gui import TestCaseGui
   class myTests(TestCaseGui):

       def testOne(self):
          for (s1, m1, s2, m2, s, m) in [(9, 35, 12, 12, 2, 37), (11, 40, 12, 10, 0, 30), (10, 15, 8, 50, 1, 25)]:
             self.assertEqual((acMainSection(s1 = s1, m1 = m1, s2 = s2, m2 = m2)["s"], acMainSection(s1 = s1, m1 = m1, s2 = s2, m2 = m2)["m"]),  (s, m) ,"Ако је Јелена стигла у %s:%s, а Ивана у %s:%s, онда је Јелена чекала Ивану %s сата и %s минута." % (s1, m1, s2, m2, s, m))
   myTests().main()

.. reveal:: чекање_на_станици_решење1
   :showtitle: Прикажи решење
   :hidetitle: Сакриј решење

   .. activecode:: чекање_на_станици_решење2
		
      s1 = int(input())
      m1 = int(input())
      s2 = int(input())
      m2 = int(input())
      vreme1 = s1*60 + m1
      vreme2 = s2*60 + m2
      vreme = abs(vreme1 - vreme2)
      s = vreme // 60
      m = vreme % 60
      print(s, "sati i", m, "minuta")


Просек 3 броја
''''''''''''''
.. level:: 2

.. questionnote::

   Димитрије, Ања, Ивона и Марко су високи редом 165, 162, 158 и
   171 cm. Пријављују трочлану екипу за школски турнир у кошарци и у
   формулару је неопходно да наведу просечну висину своје екипе, али
   се још нису одлучили ко ће сачињавати екипу. Дефиниши функцију за
   израчунавање просека три броја, а затим испиши просечне висине за
   сваку од 4 могуће варијанте трочлане екипе.

   
.. activecode:: просек3броја

   # definiši funkciju prosek koja izračunava prosek 3 data broja
   def ...

   dimitrije = 165
   anja = 162
   ivona = 158
   marko = 171
   print("Anja, Ivona, Marko:", prosek(anja, ivona, marko))
   print("Dimitrije, Ivona, Marko:", prosek(dimitrije, ivona, marko))
   # dopuni program za preostale dve kombinacije
