14.1. Торке и листе
#########################

У свим програмима које смо до сада писали податке смо чували у
појединачним променљивама. То су били обично појединачни бројеви или
евентуално краћи делови текста (нпр. име или презиме).  Елементарни
подаци које смо до сада сретали били су цели бројеви (типа ``int``),
реални бројеви (типа ``float``), логичке вредности (типа ``bool``) и
ниске (типа ``str``). У многим реалним применама имамо потребу да у
програму запамтимо, а касније и обрадимо веће количине података. У тим
ситуацијама коришћење појединачних променљивих за памћење сваког
појединачног података није практично или, чак, није могуће и потребно је
користити **структуре података** које нам омогућавају да помоћу једне
променљиве представимо читаве **колекције** података, које се састоје
од више вредности неког једноставнијег типа. У зависности од података
које желимо да сачувамо и операција које са њима желимо да спроведемо,
бирамо коју од неколико различитих врста структура података које имамо
на располагању треба да употребимо.


Погледајмо на почетку наредни видео:

.. ytpopup:: o2AZmGDDcEg
    :width: 735
    :height: 415
    :align: center


Торке и листе
-------------

Запитајмо се како бисмо у програму могли представити списак имена
кошаркаша у једном тиму? Нека је то наша кошаркашка репрезентација
која се 2019. такмичила на светском првенству у
кошарци. Претпоставићемо да сваки играч има свој редни број и то од 1
до 12.

Један могући начин би био да уведемо пуно засебних променљивих:

.. activecode:: кошаркаши_без_листе
   :passivecode: true

   igrac1 = "Никола Јокић"
   igrac2 = "Богдан Богдановић"
   igrac3 = "Немања Бјелица"
   igrac4 = "Василије Мицић"
   ...

Међутим, оваква репрезентација података није згодна јер не можемо
једноставно да одговоримо на разна интересантна питања о кошаркашима
(на пример, колико укупно има играча, ко носи број који се уноси са
улаза, који број носи неки дати играч и слично). Бољи начин да
представимо списак играча је да употребимо **торку** или **листу**.
На пример, торку имена кошаркаша можемо дефинисати на следећи начин.

.. activecode:: кошаркаши_торка
   :passivecode: true
                 
   igraci = ("Стефан Јовић", "Василије Мицић", "Богдан Богдановић",
             "Марко Гудурић", "Марко Симоновић", "Владимир Лучић",
	     "Стефан Бирчевић", "Немања Бјелица", "Никола Јокић",
	     "Бобан Марјановић", "Мирослав Радуљица", "Никола Милутинов")

.. infonote::
   
   Запис облика (35, 128) се у математици назива *уређени пар*, запис
   облика (250, 120, 310) *уређена тројка*, запис облика (135, 22,
   83, 57) *уређена четворка* итд. Када дужина није позната, каже се
   *уређена n-торка* (*уређена енторка*), али у програмирању је
   одомаћено краће име - *торка*.
             
Дакле, торку дефинишемо тако што између обичних малих заграда (заграда
``(`` и ``)``) наводимо елементе раздвојене зарезима. Приметимо да је
листа имена кошаркаша веома дугачка, тако да смо је прегледности ради
разбили у више редова. Иако у општем случају није допуштено делити
наредбе на више линија, то је могуће ако је садржај тих линија окружен
неким заградама (пошто је у првој линији отворена заграда ``(``, након
читања прве, аутоматски се читају и друга и трећа и четврта линија, све
док се не наиђе на затворену заграду ``)``).

Дефинисање листе би се разликовало од дефинисања торке само по томе
што би се уместо обичних малих заграда ``(...)`` употребиле угласте
заграде употребиле обичне заграде ``[...]``.


.. activecode:: кошаркаши_листа
   :passivecode: true
                 
   igraci = ["Стефан Јовић", "Василије Мицић", "Богдан Богдановић",
             "Марко Гудурић", "Марко Симоновић", "Владимир Лучић",
	     "Стефан Бирчевић", "Немања Бјелица", "Никола Јокић",
	     "Бобан Марјановић", "Мирослав Радуљица", "Никола Милутинов"]


Суштинска разлика између торке и листе је то што је торка
**имутабилна** што значи да јој не можемо мењати вредности када је
једном дефинишемо. Са друге стране, листе допуштају да им мењамо
појединачне елементе, уклањамо елементе, додајемо нове и слично. Све
операције у којима се врши анализа садржаја биће идентичне, без обзира
да ли се ради о листи или о торки и описаћемо их у наставку (иако ћемо
у примерима користити торке, све оне се на потпуно исти начин могу
применити и на листе). Операције у којима се врши промена су
специфичне за листе и није их могуће спровести над торкама па ћемо њих
описати засебно.
             
Појединачни чланови торке или листе називају се и
**елементи**. Елементи могу бити ниске (као у овом примеру), али и
бројеви, друге торке или листе и било шта друго. Чак је могуће у исту
торку тј. листу поставити елементе различитог типа. Као пример торке
бројева, формирајмо торку висина ових наших кошаркаша.

.. activecode:: висине_кошаркаша
   :passivecode: true

   visine = (198, 197, 198, 198, 203, 203, 210, 208, 213, 221, 213, 212)

Двочлане торке (уређени парови) и вишечлане торке ( уређене тројке,
четворке итд.) се најчешће користе за груписање тек неколико
појединачних података. На пример, позицију фигуре на шаховској табли
можемо представити помоћу уређеног пара који чини ознака врсте (слова
од ``a`` до ``h``) и ознака колоне (броја од 1 до 8). На пример,
``("b", 6)``. Слично, позиције на географској карти се описују помоћу
географске ширине и дужине тј. помоћу пара реалних бројева.  Тако се
град Париз налази на позицији која се може описати помоћу пара
``(48.8566, 2.3522)``. Време можемо представити помоћу уређене тројке
коју чине сат, минут и секунд (на пример, ``(7, 25, 37)``).

За груписање већег броја података чешће се користе листе, поготово ако
није унапред познато колико таквих података може бити тј. ако се број
података може изменити током рада програма. На пример, ако желимо да
представимо оцене ученика, чешће бисмо употребили листу јер ученик
може да добије још неку оцену, па је листу његових оцена потребно
проширити, што није могуће ако се оцене представе торком.

.. infonote::

   Већина програмских језика не разликује имутабилне и мутабилне
   колекције. Зато програмери често користе искључиво листе, чак и у
   ситуацијама када је коришћење торки примереније. То се не сматра
   великим пропустом.

   
Издвајање елемената
&&&&&&&&&&&&&&&&&&&

Елементима торке (или листе) приступа се на основу њихове **позиције**
тј. **индекса**. Бројање креће од нуле. Први елемент листе се налази
на позицији 0, други на позицији 1 и тако даље.  На пример, елементи
у листи ``a = [3, 7, 4, 2, 5]`` се броје на следећи начин.

+------------+-+-+-+-+-+
|индекс      |0|1|2|3|4|
+------------+-+-+-+-+-+
|вредност    |3|7|4|2|5|
+------------+-+-+-+-+-+

Зато је првом елементу могуће приступити са ``a[0]`` и вредност тога
израза је ``3`` (јер се на позицији 0 у листи налази број ``3``),
другом елементу са ``a[1]`` и вредност тог израза је ``7`` и тако
даље.

Негативни индекси упућују на бојање од краја (с десна на лево), па -1
означава последњи елемент, -2 претпоследњи и тако даље.

+--------+---+---+---+---+--+
|индекс  | -5| -4| -3| -2|-1|
+--------+---+---+---+---+--+
|вредност| 3 | 7 | 4 | 2 | 5|
+--------+---+---+---+---+--+

Зато је последњем елементу могуће приступити помоћу ``a[-1]``,
претпоследњем помоћу ``a[-2]`` итд.

Још једна операција која је често корисна је издвајање дела торке
тј. листе.  Елементима између позиција ``a`` и ``b`` укључујући
позицију ``a``, али искључујући позицију ``b`` могуће је приступити
помоћу ``a[a:b]``.

На пример, ``ime[1:4]`` издваја елементе имена на позицијама 1, 2 и 3
(распон ``[1:4]`` је полуотворен тј. позиција 1 је урачуната, а
позиција 4 није). Ако је ``a = [3, 7, 4, 2, 5]`` тада је ``a[1:4]``
листа чија је вредност ``[7, 4, 2]``. Ако се изостави број иза
двотачке, издвајају се елементи до краја. На пример ``a[2:]`` је листа
која има вредност ``[4, 2, 5]``.

Употребимо ове операције да решимо неколико задатака о нашим играчима.

Играч са датим бројем дреса
'''''''''''''''''''''''''''

.. questionnote::

  Познат је списак играча у тиму. Они носе дресове са бројевима од 1
  па на даље. Напиши програм који за дати број дреса одређује играча
  који игра под тим редним бројем.

Пошто се уносе бројеви од 1 до дужине торке (или листе), а индекси се
крећу од 0 па до претходника дужине торке, након учитавања броја дреса
приступиће се елементу чији је индекс за 1 мањи од броја дреса.
   
.. activecode :: висина_играча_са_датим_бројем

   igraci = ("Стефан Јовић", "Василије Мицић", "Богдан Богдановић",
             "Марко Гудурић", "Марко Симоновић", "Владимир Лучић",
	     "Стефан Бирчевић", "Немања Бјелица", "Никола Јокић",
	     "Бобан Марјановић", "Мирослав Радуљица", "Никола Милутинов")
   dres = int(input("Број дреса: "))
   print(igraci[dres - 1])

Начин да се избегне ово померање индекса за 1 био би да се на почетно
место убаци неки вештачки елемент (на пример, празна ниска).

.. activecode :: играч_са_датим_бројем_1

   igraci = ("", "Стефан Јовић", "Василије Мицић", "Богдан Богдановић",
             "Марко Гудурић", "Марко Симоновић", "Владимир Лучић",
	     "Стефан Бирчевић", "Немања Бјелица", "Никола Јокић",
	     "Бобан Марјановић", "Мирослав Радуљица", "Никола Милутинов")
             
   dres = int(input("Број дреса: "))
   print()   # dopuni ovaj red

   

Распакивање
&&&&&&&&&&&

Ако знамо дужину торке или листе, могуће је на лак начин именовати
сваки њен елемент тј. сместити сваки елемент у посебну променљиву.

На пример, претпоставимо да торка ``matematicari`` садржи пуна имена
четири велика математичара: Ренеа Декарта, Жозефа Луја Лагранжа, Карла
Фридриха Гауса и Леонарда Ојлера. Направимо четири посебне променљиве
``dekart``, ``lagranz``, ``gaus`` и ``ojler`` које ће садржати пуна
имена одговарајућих математичара.

Један начин да се то уради је да се помоћу индекса приступи појединачним
елементима. 

.. activecode:: математичари

   matematicari = ["Рене Декарт", "Жозеф Луј Лагранж", "Карл Фридрих Гаус", "Леонард Ојлер"]
   dekart = matematicari[0]
   lagranz = matematicari[1]
   gaus = matematicari[2]
   ojler = matematicari[3]
		
Међутим, постоји и једноставнији начин да се постигне исти ефекат.
   
.. activecode:: распакивање_листе

   matematicari = ["Рене Декарт", "Жозеф Луј Лагранж", "Карл Фридрих Гаус", "Леонард Ојлер"]
   dekart, lagranz, gaus, ojler = matematicari
   print(gaus)

Првој променљивој са леве стране се додељује први елемент листе са
десне стране, другој променљивој други елемент листе и тако даље. Овај
поступак називамо **распакивање**. Исти ефекат би се постигао и да су
четири променљиве са леве стране биле наведене у склопу торке
тј. листе.

.. activecode:: распакивање_листе_1

   matematicari = ["Рене Декарт", "Жозеф Луј Лагранж", "Карл Фридрих Гаус", "Леонард Ојлер"]
   [dekart, lagranz, gaus, ojler] = matematicari
   print(gaus)
   
Распакивање се може применити и на уређене парове и торке. Примени то
у решавању наредног једноставног задатка.



Функције за рад са торкама и листама
&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&

Језик Python нам на располагање ставља неколико функција којима можемо
одредити често коришћене статистике елемената листе. Функцијом ``len``
израчунавамо дужину листе, функцијом ``sum`` израчунавамо збир
елемената листе, функцијом ``min`` најмањи елемент у листи, а
функцијом ``max`` највећи. Ове функције можемо употребити да
једноставно решимо разне практичне задатке.

Просечна оцена
''''''''''''''


.. questionnote::

   Дате су оцене из неколико предмета. Израчунај просечну оцену.

Просек тј. аритметичка средина се једноставно добија дељењем збира
елемената њиховим бројем.
   
.. activecode:: просек_оцена
		
   ocene = [5, 4, 5, 3, 5]
   prosek = sum(ocene) / len(ocene)
   print(prosek)

   
Најмања оцена
'''''''''''''
   
.. questionnote::

   Ако се зна да су оцене из природних наука последње три у листи
   оцена, израчунај Горанову најмању оцену из тих предмета.

У овом задатку комбиновање идвајање сегмента елемената торке и
функцију за проналажење минимума.
   
.. activecode:: последње_оцене

   ocene = (5, 4, 5, 3, 5, 4, 4, 5)
   ocene_iz_prirodnih_nauka = ocene[-3:] 
   print(min(ocene_iz_prirodnih_nauka))



Претрага
&&&&&&&&

Погледајмо на почетку наредни видео:

.. ytpopup:: 2bhMU5uiMSU
    :width: 735
    :height: 415
    :align: center

Проверу да ли елемент припада торки тј. листи могуће је извршити
коришћењем оператора ``in`` (на пример, ``"Бобан Марјановић" in
igraci``). У наредном примеру проверавамо да ли је кошаркаш чије се
име и презиме учитавају при покретању програма играо за репрезентацију
на СП 2019. године.

.. activecode:: Калинић_не_игра
   
   igraci = ["", "Стефан Јовић", "Марко Симоновић", "Богдан Богдановић",
             "Никола Калинић", "Милан Мачван", "Стефан Марковић",
	     "Немања Недовић", "Мирослав Радуљица", "Милош Теодосић",
	     "Никола Јокић", "Владимир Штимац", "Стефан Бирчевић"]
   igrac = input("Унеси име и презиме кошаркаша:")
   if igrac in igraci:
       print(igrac, "је играо за репрезентацију")
   else:
       print(igrac, "није играо за репрезентацију")


Проналажење најмање позиције (индекса) на којој се налази неки тражени
елемент може се урадити коришћењем методе ``index``, којој се као
једини параметар прослеђује елемент који се тражи.

.. infonote::

   Методе су посебан облик функција које се позивају у облику
   ``struktura.funkcija(parametri)``, уместо у облику
   ``funkcija(struktura, parametri)``. Дакле, ако у листи ``igraci``
   тражимо Николу Јокића, уместо да наведемо ``index(igraci, "Никола
   Јокић")``, навешћемо ``igraci.index("Никола Јокић")``. Приметимо да
   су све наредбе корњачи заправо биле методе (користили смо
   ``turtle.forward(100)``, а не ``forward(turtle, 100)``.



Надовезивање
&&&&&&&&&&&&

Две торке тј. листе можемо надовезати (спојити у једну) коришћењем
операције ``+``. Тиме се формира нова торка тј. листа, док се
оригинали не мењају. Није могуће надовезати торку и листу, нити листу
и торку.

Висине девојчица и дечака у одељењу
'''''''''''''''''''''''''''''''''''


.. questionnote::

 Познате су висине девојчица и висине дечака у једном одељењу. Направи
 торку свих висина и израчунај затим број и просечну висину свих ђака.

.. activecode:: спајање_листа
 
   visine_devojcica = [165, 153, 155, 155, 157]
   visine_decaka = [170, 168, 173, 156, 172]
   visine = visine_devojcica + visine_decaka
   print(len(visine))
   print(sum(visine) / len(visine))

Слично као што код бројева множење представља узастопно сабирање, исти
је случај и овде и може се наслутити да множење ниске природним бројем
заправо представља њено понављање одређени број пута. На пример, ако
желимо да направимо листу која садржи 100 нула, то можео урадити
изразом ``[0] * 100``, док израз ``(0, 1, 2) * 3`` гради торку ``(0,
1, 2, 0, 1, 2, 0, 1, 2)``.
   
Сортирање
&&&&&&&&&

Елементе торке тј. листе је веома једноставно уредити од најмањег до
највећег (па и обратно, од највећег до најмањег). Функција ``sorted``
се може применити и на торке и на листе и она на основу датих података
гради нову торку тј. листу која садржи исте податке, у сортираном
редоследу. Метода ``sort`` применљива је само на листе и она мења
листу тако што јој елементе rеђа у сортираном редоследу. Ово је
ефикасније него да се прави нова листа, али се оригинални редослед
елемената губи.


Три најјефтинија и најскупља производа
''''''''''''''''''''''''''''''''''''''


.. questionnote::

   Дата је листа цена производа. Колико коштају три најјефтинија, а
   колико три најскупља производа?

.. activecode:: најјефтинији_и_најскупљи_производи

   cene = (58.00, 104.95, 117.50, 11.95, 10.4, 37.95, 85.5)
   sortirane_cene = sorted(cene)
   print(sum(sortirane_cene[0:3]))
   print(sum(sortirane_cene[-3:]))

   

   
Враћање торки из функције
&&&&&&&&&&&&&&&&&&&&&&&&&

Као што смо већ раније поменули, торке могу бити веома корисне да би
се вратило више вредности из функције. Подсетимо сеове корисне
технике.

Конверзија угла у степене и минуте
''''''''''''''''''''''''''''''''''

	   
.. questionnote::

  Напиши функцију која за угао дат у облику децималног броја степени
  одређује њему најближи угао дат у степенима и минутима. Употреби га
  да одредиш колико степени и минута има угао :math:`36,2^\circ`.

.. activecode:: функција_враћа_торку
  
   def ugao(alfa):
       # prevodimo ugao u minute i zaokruzujemo na najblizi ceo broj
       alfa_min = int(round(alfa * 60))
       # izdvajamo stepene i minute
       stepeni = alfa_min // 60
       minuta = alfa_min % 60
       # vracamo rezultat
       return (stepeni, minuta)

   (stepeni, minuta) = ugao(36.2);
   print(stepeni, ":", minuta)

Приметимо да се приликом прихватања резултата врши распакивање торке
тј. да се променљивима ``stepeni`` и ``minuta`` додељују редом први и
други елемент уређеног пара који је функција вратила.


Измене листе
''''''''''''

Торке и ниске су имутабилни типови података, што значи да се, када се
једном формирају, они не могу даље мењати. Са друге стране, листе је
могуће мењати. Појединачни елементи листе се могу мењати на следећи
начин.

.. activecode:: измена_елемената_листе

   boje = ["red", "green", "blue"]
   boje[0] = "purple"
   boje[2] = "orange"
   print(boje)

На првом месту у листи црвену боју смо заменили љубичастом, а на
последњем плаву са нарандџастом, тако да на крају програма листа
``boje`` чува вредности ``["purple", "green", "orange"]``.

Елемент на крај листе можемо додати методом ``append``. На пример,
уместо да мењамо, листу боја можемо да проширимо за две вредности.

.. activecode:: додавање_елемената_у_листу

   boje = ["red", "green", "blue"]
   boje.append("purple")
   boje.append("orange")
   print(boje)

На крају овог програма, листа садржи вредности ``["red", "green",
"blue", "purple", "orange"]``.

Елементе из листе можемо брисати помоћу ``del``. На пример, ако из
листе дана желимо да обришемо дане викенда, то можемо урадити на
наредни начин.

.. activecode:: брисање_елемената_из_листе

   dani = ["nedelja", "ponedeljak", "utorak", "sreda", "četvrtak", "petak", "subota"]
   del dani[6]
   del dani[0]
   print(dani)

Сложене торке и листе
&&&&&&&&&&&&&&&&&&&&&

Торке и листе могу да буду елементи других торки тј. листа. Направимо,
на пример, торку која садржи податке о месецима током једне године
која није преступна. За сваки месец знамо назив и број дана и те
податке ћемо организовати помоћу уређених парова (на пример,
``("април", 30)``).

Дани у месецу
'''''''''''''


.. activecode:: листа_торки

   meseci = (("јануар", 31), ("фебруар", 28), ("март", 31), \
             ("април", 30), ("мај", 31), ("јун", 30), \
             ("јул", 31), ("август", 31), ("септембар", 30), \
	     ("октобар", 31), ("новембар", 30), ("децембар", 31))
   broj = int(input("Унеси редни број месеца:"))
   mesec = meseci[broj - 1]
   print("Назив:", mesec[0], "Број дана:", mesec[1])

   
Помоћну променљиву ``mesec`` није било неопходно користити. Поправи
индексе у наредном програму тако да ради исто као и претходни.

.. activecode:: листа_торки_1

   meseci = (("јануар", 31), ("фебруар", 28), ("март", 31), \
             ("април", 30), ("мај", 31), ("јун", 30), \
             ("јул", 31), ("август", 31), ("септембар", 30), \
	     ("октобар", 31), ("новембар", 30), ("децембар", 31))
   broj = int(input("Унеси редни број месеца:"))
   # popravi indekse u narednom redu
   print("Назив:", meseci[0][0], "Број дана:", meseci[0][0])

